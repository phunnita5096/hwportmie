<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Medieval Book ‚Ä¢ three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    html, body { height:100%; margin:0; overflow:hidden; }
    canvas { display:block; }
    #loadingScreen {
      position: fixed; inset:0;
      background-color:#ffe6f2;
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      z-index:9999; font-family:'Press Start 2P', cursive; color:#ff69b4;
      text-align:center; opacity:1; transition: opacity 10s ease;
    }
    #heartBar { width:200px; height:20px; border:2px solid #ff69b4; border-radius:10px; background-color:#ffd6e8; overflow:hidden; }
    #progress { width:0%; height:100%; background-color:#ff69b4; border-radius:10px; transition: width 3s ease; }
  </style>
</head>
<body>
  <div id="loadingScreen">
    <div style="font-size:24px; margin-bottom:20px;">Portfolio Phunnita Kumpapan LOADING...</div>
    <div id="heartBar"><div id="progress"></div></div>
    <div style="margin-top:10px; font-size:12px;">üíñ Please wait üíñ</div>
  </div>

  <script>
    // Scene & Camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(25,28,45);

    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(5,8,0);
    controls.update();
    const defaultCameraPos = new THREE.Vector3();
    const defaultTarget = new THREE.Vector3();

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff,0x333333,0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(3,5,2);
    dir.castShadow = true;
    scene.add(dir);

    // Loading Manager
    const manager = new THREE.LoadingManager(
      () => {
        const loadingScreen = document.getElementById("loadingScreen");
        setTimeout(()=>{loadingScreen.style.opacity="0"; setTimeout(()=>loadingScreen.remove(),2500);},1000);

        // Smooth camera intro
        const start = {x:50,y:50,z:100}, end={x:25,y:30,z:50}, duration=4000, startTime=performance.now();
        function smoothMove(time){
          const t=Math.min((time-startTime)/duration,1);
          const ease=t<0.5?2*t*t:-1+(4-2*t)*t;
          camera.position.set(
            start.x+(end.x-start.x)*ease,
            start.y+(end.y-start.y)*ease,
            start.z+(end.z-start.z)*ease
          );
          controls.target.set(-8,4,0);
          controls.update();
          if(t<1) requestAnimationFrame(smoothMove);
          else { defaultCameraPos.copy(camera.position); defaultTarget.copy(controls.target); }
        }
        requestAnimationFrame(smoothMove);
      },
      (url, loaded, total) => { document.getElementById("progress").style.width=Math.round((loaded/total)*100)+"%"; }
    );

    // Load EXR
    const exrLoader = new THREE.EXRLoader(manager);
    exrLoader.load('industrial_sunset_02_puresky_1k.exr', (texture)=>{
      texture.mapping = THREE.EquirectangularReflectionMapping;
      texture.colorSpace = THREE.SRGBColorSpace;
      scene.background = texture;
      scene.environment = texture;
    });

    // Load Model
    const loader = new THREE.GLTFLoader(manager);
    let mixer=null;
    const clock=new THREE.Clock();
    loader.load('scene.gltf',(gltf)=>{
      const model=gltf.scene;
      model.traverse(n=>{if(n.isMesh){n.castShadow=true; n.receiveShadow=true;}});
      if(gltf.animations.length){mixer=new THREE.AnimationMixer(model); gltf.animations.forEach(c=>mixer.clipAction(c).play());}
      scene.add(model);
    });

    // Resize
    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

    // Animate
    function animate(){
      requestAnimationFrame(animate);
      const delta=clock.getDelta();
      if(mixer) mixer.update(delta);
      renderer.render(scene,camera);
    }
    animate();

    // ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏∏‡∏°‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å
    (function(){
      let isReturning=false;
      function returnCameraToDefault(duration=3000){
        if(isReturning) return;
        isReturning=true;
        const startTime=performance.now();
        const startPos=camera.position.clone();
        const startTarget=controls.target.clone();
        function animateReturn(time){
          const t=Math.min((time-startTime)/duration,1);
          const ease=t<0.5?2*t*t:-1+(4-2*t)*t;
          camera.position.lerpVectors(startPos,defaultCameraPos,ease);
          controls.target.lerpVectors(startTarget,defaultTarget,ease);
          controls.update();
          if(t<1) requestAnimationFrame(animateReturn);
          else isReturning=false;
        }
        requestAnimationFrame(animateReturn);
      }
      window.addEventListener('click',()=>returnCameraToDefault(4000));
    })();

    // GUI (dat.GUI)
    const gui = new dat.GUI({width:300});
    const lightFolder = gui.addFolder('Lights');
    const lightSettings = {
      HemisphereLight: true,
      DirectionalLight: true,
      HemiIntensity: hemi.intensity,
      DirIntensity: dir.intensity,
    };
    lightFolder.add(lightSettings,'HemisphereLight').onChange(v=>hemi.visible=v);
    lightFolder.add(lightSettings,'DirectionalLight').onChange(v=>dir.visible=v);
    lightFolder.add(lightSettings,'HemiIntensity',0,2,0.1).onChange(v=>hemi.intensity=v);
    lightFolder.add(lightSettings,'DirIntensity',0,2,0.1).onChange(v=>dir.intensity=v);
    lightFolder.open();

    const camFolder = gui.addFolder('Camera Views');
    const cameraViews = {
      'Default': {pos:[25,28,45], tgt:[3,8,0]},
      'KU': {pos:[1,2,2], tgt:[3,2,8]},
      'UFO': {pos:[-47,9,12], tgt:[2,5,2]},
    };

    // ===== ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏π‡∏ó =====
    let isMovingCamera = false; // global flag

    function moveCameraTo(viewName, duration=2000){
      if(isMovingCamera) return; // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô animate ‡∏ã‡πâ‡∏≠‡∏ô
      const view = cameraViews[viewName];
      if(!view) return;

      isMovingCamera = true;

      const startTime = performance.now();
      const startPos = camera.position.clone();
      const startTgt = controls.target.clone();
      const endPos = new THREE.Vector3(...view.pos);
      const endTgt = new THREE.Vector3(...view.tgt);

      function animateMove(time){
        const t = Math.min((time - startTime)/duration, 1);
        const ease = t*t*(3-2*t); // smoothstep easing

        camera.position.lerpVectors(startPos, endPos, ease);
        controls.target.lerpVectors(startTgt, endTgt, ease);
        controls.update();

        if(t < 1) requestAnimationFrame(animateMove);
        else {
          defaultCameraPos.copy(camera.position);
          defaultTarget.copy(controls.target);
          isMovingCamera = false; // animation ‡πÄ‡∏™‡∏£‡πá‡∏à
        }
      }
      requestAnimationFrame(animateMove);
    }

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° GUI
    Object.keys(cameraViews).forEach(name => {
      camFolder.add({ go: () => moveCameraTo(name) }, 'go').name(name);
    });
    camFolder.open();
  </script>
</body>
</html>
