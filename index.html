<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mushroom Kingdom 3D</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>

<!-- ‚úÖ ‡πÇ‡∏´‡∏•‡∏î Three.js + Loader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
  // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Scene
  const scene = new THREE.Scene();

  // ‚úÖ ‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡πÉ‡∏Å‡∏•‡πâ‡∏≠‡∏≤‡∏ì‡∏≤‡∏à‡∏±‡∏Å‡∏£)
  const camera = new THREE.PerspectiveCamera(
    60, window.innerWidth / window.innerHeight, 0.1, 2000
  );
camera.position.set(8, 12, 10);
camera.lookAt(0, 6, 0);

  // ‚úÖ Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  // ‚úÖ Controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.target.set(0, 3, 0);
  controls.update();

  // ‚úÖ ‡πÅ‡∏™‡∏á
  // ‚úÖ ‡πÅ‡∏™‡∏á‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡∏â‡∏≤‡∏Å
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // ‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏±‡πà‡∏ß
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // ‡πÅ‡∏™‡∏á‡∏´‡∏•‡∏±‡∏Å
dirLight.position.set(20, 50, 20);
dirLight.castShadow = true;
scene.add(dirLight);

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏™‡∏á‡∏ü‡πâ‡∏≤‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏™‡∏°‡∏à‡∏£‡∏¥‡∏á
const hemiLight = new THREE.HemisphereLight(0x88ccff, 0x444422, 0.6);
hemiLight.position.set(0, 50, 0);
scene.add(hemiLight);

// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° exposure ‡∏Ç‡∏≠‡∏á renderer
renderer.toneMappingExposure = 0.4;


  // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î Environment (EXR)
  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();

  const exrLoader = new THREE.EXRLoader();
  exrLoader.load("solitude_night_1k.exr", (texture) => {
    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
    scene.background = envMap;     
    scene.environment = envMap;    
    texture.dispose();
    pmremGenerator.dispose();
  });

  // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• Mushroom Kingdom (.glb)
  // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• final1.glb ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ (‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì)
const loader2 = new THREE.GLTFLoader();
loader2.load(
  "final1.glb",
  (gltf) => {
    const nameModel = gltf.scene;

    // ‡∏Ç‡∏ô‡∏≤‡∏î / ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
    nameModel.scale.set(1, 1, 1);
    nameModel.position.set(-1, 4, 0); // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£

    // ‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏£‡∏á: ‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏Å‡∏ô X 90¬∞ (‡∏ñ‡πâ‡∏≤‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ô‡∏≠‡∏ô‡∏£‡∏≤‡∏ö)
   nameModel.rotation.x = 0;   // ‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏£‡∏á
nameModel.rotation.y = 0;   // ‡∏´‡∏°‡∏∏‡∏ô‡∏´‡∏±‡∏ô‡∏Ç‡∏ß‡∏≤ 90¬∞
nameModel.rotation.z = 0;


    scene.add(nameModel);
    console.log("‚úÖ Loaded final1.glb (‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏£‡∏á + ‡∏ä‡∏¥‡∏î‡∏ã‡πâ‡∏≤‡∏¢ + ‡∏¢‡∏Å‡∏™‡∏π‡∏á)");
  },
  (xhr) => {
    console.log(Math.round((xhr.loaded / xhr.total) * 100) + "% loaded (final1.glb)");
  },
  (error) => {
    console.error("‚ùå Error loading final1.glb:", error);
  }
);

  // ‚úÖ Render loop
  function render() {
    requestAnimationFrame(render);
    controls.update();
    renderer.render(scene, camera);
  }
  render();

  // ‚úÖ Resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
</script>
<script>
  // ‚úÖ ‡∏ï‡∏±‡∏ß‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å (Raycaster)
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  // ‚úÖ ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ animation
  let animating = false;
  let progres = 0;
  const startCamPos = camera.position.clone();
  const startTarget = controls.target.clone();
  const aboutCamPos = new THREE.Vector3(8, 10, 2); // üëà ‡∏õ‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡πÑ‡∏õ
  const aboutTarget = new THREE.Vector3(0, 5, 0);

  // ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å
  window.addEventListener("click", (event) => {
    pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    for (let i = 0; i < intersects.length; i++) {
      const obj = intersects[i].object;
      if (obj.name === "About me") { // üëà ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏ô GLB
        animating = true;
        progress = 0;
        break;
      }
    }
  });

  // ‚úÖ hook ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö render ‡πÄ‡∏î‡∏¥‡∏°‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÅ‡∏ï‡∏∞‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°
  const oldRender = render;
  render = function() {
    if (animating) {
      progress += 0.02;
      if (progress >= 1) {
        progress = 1;
        animating = false;
      }
      // ‡∏Ñ‡πà‡∏≠‡∏¢ ‡πÜ ‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á
      camera.position.lerpVectors(startCamPos, aboutCamPos, progress);
      const targetNow = new THREE.Vector3().lerpVectors(startTarget, aboutTarget, progress);
      controls.target.copy(targetNow);
      camera.lookAt(targetNow);
    }
    oldRender(); // render ‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
  };
 </script>
<!-- üíñ Cute Loading Screen -->
 <div id="loadingScreen" style="
  position: fixed;
  inset: 0;
  background-color: #ffe6f2;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  font-family: 'Press Start 2P', cursive;
  color: #ff69b4;
  text-align: center;
">
  <div style="font-size: 24px; margin-bottom: 20px;">LOADING...</div>
  <div id="heartBar" style="
    width: 200px;
    height: 20px;
    border: 2px solid #ff69b4;
    border-radius: 10px;
    background-color: #ffd6e8;
    overflow: hidden;
    position: relative;
  ">
    <div id="progress" style="
      width: 0%;
      height: 100%;
      background-color: #ff69b4;
      border-radius: 10px;
      transition: width 0.2s;
    "></div>
  </div>
  <div style="margin-top: 10px; font-size: 12px;">üíñ Please wait üíñ</div>
</div>

<!-- ‡πÇ‡∏´‡∏•‡∏î‡∏ü‡∏≠‡∏ô‡∏ï‡πå‡∏û‡∏¥‡∏Å‡πÄ‡∏ã‡∏• -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<script>
 
  const loadingScreen = document.getElementById("loadingScreen");
  const progress = document.getElementById("progress");

  // ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î (‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏ó‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÇ‡∏´‡∏•‡∏î glb ‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏î‡πâ)
  let load = 0;
  const fakeLoading = setInterval(() => {
    load += 2;
    progress.style.width = load + "%";
    if (load >= 100) {
      clearInterval(fakeLoading);
      // ‡πÉ‡∏´‡πâ fade out ‡∏™‡∏ß‡∏¢ ‡πÜ
      loadingScreen.style.transition = "opacity 1s ease";
      loadingScreen.style.opacity = 0;
      setTimeout(() => {
        loadingScreen.style.display = "none";
        startCameraZoom(); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏π‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á
      }, 1000);
    }
  }, 60);

  // ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ã‡∏π‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á
  function startCameraZoom() {
    const startPos = camera.position.clone();
   const targetPos = new THREE.Vector3(6.2, 8.5, -3.4); 
    const duration = 2000;
    const startTime = performance.now();

    function animateCamera(time) {
      const t = Math.min((time - startTime) / duration, 1);
      camera.position.lerpVectors(startPos, targetPos, t);
      camera.lookAt(2, 8, 0);
      controls.update();
      if (t < 1) requestAnimationFrame(animateCamera);
    }

    requestAnimationFrame(animateCamera);
  }
</script>
<script>
  // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Raycaster ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏µ
  const colorRaycaster = new THREE.Raycaster();
  const colorPointer = new THREE.Vector2();

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö click / touch
  function handleClick(event) {
    event.preventDefault();

    // ‡∏£‡∏±‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î pointer
    if(event.touches){ // touch event
      colorPointer.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
      colorPointer.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
    } else { // mouse click
      colorPointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      colorPointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    colorRaycaster.setFromCamera(colorPointer, camera);
    const intersects = colorRaycaster.intersectObjects(scene.children, true);

    intersects.forEach(i => {
      if(i.object.name === "About me") {
        // ‚úÖ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≤‡∏ß
        if(i.object.material) {
          i.object.material.color.set(0xffffff);
        } else if(i.object.children.length > 0){
          i.object.traverse(child => {
            if(child.material) child.material.color.set(0xffffff);
          });
        }

        // ‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏° animate ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡∏°‡∏∏‡∏°‡πÉ‡∏´‡∏°‡πà
        animating = true;
        progres = 0;
      }
    });
  }

  window.addEventListener("click", handleClick);
  window.addEventListener("touchstart", handleClick);
</script>



</body>
</html>
